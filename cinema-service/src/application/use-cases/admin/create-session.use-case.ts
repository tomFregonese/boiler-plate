import { Inject, Injectable } from '@nestjs/common';
import { IRoomRepository } from '../../../domain/repositories/room.repository';
import { ISessionRepository } from '../../../domain/repositories/session.repository';
import { ISeatRepository } from '../../../domain/repositories/seat.repository';
import { Session } from '../../../domain/entities/session.entity';
import {
    SeatOccupation,
    OccupationStatus,
} from '../../../domain/entities/seat-occupation.entity';
import { RoomNotFoundException } from '../../../domain/exceptions/room-not-found.exception';
import { InvalidTimeSlotException } from '../../../domain/exceptions/invalid-time-slot.exception';
import { RoomAlreadyOccupiedException } from '../../../domain/exceptions/room-already-occupied.exception';
import { UnauthorizedCinemaAccessException } from '../../../domain/exceptions/unauthorized-cinema-access';
import {
    ROOM_REPOSITORY,
    SEAT_REPOSITORY,
    SESSION_REPOSITORY,
} from '../../../infrastructure/token';

@Injectable()
export class CreateSessionUseCase {
    constructor(
        @Inject(ROOM_REPOSITORY)
        private readonly roomRepository: IRoomRepository,
        @Inject(SESSION_REPOSITORY)
        private readonly sessionRepository: ISessionRepository,
        @Inject(SEAT_REPOSITORY)
        private readonly seatRepository: ISeatRepository,
    ) {}

    async execute(
        filmId: string,
        roomId: string,
        startTime: Date,
        userCinemaId: string,
    ): Promise<Session> {
        const room = await this.roomRepository.findById(roomId);
        if (!room) {
            throw new RoomNotFoundException(roomId);
        }

        if (room.cinemaId !== userCinemaId) {
            throw new UnauthorizedCinemaAccessException(
                userCinemaId,
                room.cinemaId,
            );
        }

        const hour = startTime.getHours();
        if (![10, 13, 16, 19].includes(hour)) {
            throw new InvalidTimeSlotException(hour);
        }

        const existingSessions =
            await this.sessionRepository.findByRoomIdAndDate(roomId, startTime);

        const conflictingSession = existingSessions.find(
            (s) => s.startTime.getHours() === hour,
        );

        if (conflictingSession) {
            throw new RoomAlreadyOccupiedException(roomId, startTime);
        }

        const seats = await this.seatRepository.findByRoomId(roomId);
        const seatOccupations = seats.map(
            (seat) =>
                new SeatOccupation(
                    '', // sessionId will be set after creation
                    seat.id,
                    OccupationStatus.FREE,
                    undefined,
                ),
        );

        const session = new Session(
            '', // id will be generated by repository
            filmId,
            roomId,
            startTime,
            seatOccupations,
        );

        return this.sessionRepository.create(session);
    }
}
